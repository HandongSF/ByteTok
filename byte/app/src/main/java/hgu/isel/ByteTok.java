/*
 * This source file was generated by the Gradle 'init' task
 */
package hgu.isel;

import hgu.isel.analyzer.ByteAnalyzer;
import hgu.isel.options.CommandLineOptions;
import hgu.isel.reader.ByteReader;
import hgu.isel.tokenizer.ByteStructure;
import hgu.isel.tokenizer.ByteTokenizer;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.ParseException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class ByteTok {
    private static HashSet<String> customAttributes = new HashSet<>();

    public static void main(String[] args) {
        ByteTok parser = new ByteTok();
        parser.run(args);
    }

    public void run(String[] args) {

        CommandLineOptions commandLineOptions = new CommandLineOptions();

        try {
            CommandLine cmd = commandLineOptions.parse(args);

            if(cmd.hasOption("v")) {

                String[] vocabArgs = cmd.getOptionValues("v");
                String inputPath = vocabArgs[0];
                int maximumSize = Integer.parseInt(vocabArgs[1]);
                String vocabPath = vocabArgs[2];

                createVocabulary(inputPath, maximumSize, vocabPath);

            } else if(cmd.hasOption("a")) {

                String[] tokenizeArgs = cmd.getOptionValues("a");
                String inputPath = tokenizeArgs[0];

                analyze(inputPath);

            } else if(cmd.hasOption("r")) {

                String[] removeArgs = cmd.getOptionValues("r");
                String inputPath = removeArgs[0];

                remove(inputPath);

            } else if(cmd.hasOption("g")) {

                String[] generateArgs = cmd.getOptionValues("g");
                String inputPath = generateArgs[0];
                String directory = generateArgs[1];

                generate(inputPath, directory);

            } else if(cmd.hasOption("d")) {

                String[] deleteArgs = cmd.getOptionValues("d");
                String inputPath = deleteArgs[0];

                delete(inputPath);

            } else if(cmd.hasOption("f")) {

                String[] findArgs = cmd.getOptionValues("f");
                String inputPath = findArgs[0];

                findCustomizedAttributes(inputPath);

            } else if(cmd.hasOption("e")) {

                String[] extractArgs = cmd.getOptionValues("e");
                String inputPath = extractArgs[0];
                String directory = extractArgs[1];

                extract(inputPath, directory);

            } else if(cmd.hasOption("s")) {
                String[] searchArgs = cmd.getOptionValues("s");
                String inputPath = searchArgs[0];
                String methodName = searchArgs[1];
                String outputDirectory = searchArgs[2];

                findMethodWithSignature(inputPath, methodName, outputDirectory);
            }

        } catch (ParseException e) {
            System.out.println("옵션 파싱 에러: " + e.getMessage());
            commandLineOptions.printHelp();
        }

    }

    private void createVocabulary(String path, int maximumSize, String vocabPath) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        ByteTokenizer byteTokenizer = new ByteTokenizer();


        for(String s : filePaths) {
            byte[] bytes;
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                ByteStructure byteStructure = byteAnalyzer.analyze();
                int hashSize = byteTokenizer.saveTokens(byteStructure);

                if(hashSize > maximumSize) { // up to maximum size
                    break;
                }

            } catch (Exception e) {
                e.printStackTrace();
                System.exit(0);
            }

        }
        System.out.println("Success creating vocab");
        byteTokenizer.createVocabulary(vocabPath);
    }

    private void analyze(String path) {
        ByteReader byteReader = new ByteReader(path);

        byte[] bytes = byteReader.readClassFile();

        ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
        ByteStructure byteStructure = null;
        try {
            byteStructure = byteAnalyzer.analyze();
            System.out.println(byteAnalyzer.printResult());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

    }

    private void remove(String path) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;

        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                byteAnalyzer.analyze();
                System.out.println("Success!! : " + s);
            } catch (Exception e) {
                try {
                    Path filePath = Paths.get(s);
                    Files.delete(filePath);
                    System.out.println("Deleted file: " + s);
                } catch (IOException deleteException) {
                    System.err.println("Failed to delete file: " + s);

                }
            }
        }
    }

    private void generate(String path, String directory) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;
        ByteTokenizer byteTokenizer = new ByteTokenizer();

        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                ByteStructure byteStructure = byteAnalyzer.analyze();
                byteStructure.setFileName(s);

                byteTokenizer.generateNewFilesWithConstantPool(byteStructure, directory);

                System.out.println("Success: " + s);
            } catch (Exception e) {
                System.out.println("Failed: " + s);
                e.printStackTrace();
            }


        }
    }

    private void delete(String path) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;
        ByteTokenizer byteTokenizer = new ByteTokenizer();

        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                ByteStructure byteStructure = byteAnalyzer.analyze();
                byteStructure.setFileName(s);

                boolean isDelete = byteTokenizer.removeFiles(byteStructure);

                if(isDelete) {
                    Path filePath = Paths.get(s);
                    Files.delete(filePath);

                    System.out.println("delete " + s);
                }
                System.out.println("not delete");


            } catch (Exception e) {

                e.printStackTrace();
            }
        }
    }

    private void findCustomizedAttributes(String path) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;


        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                byteAnalyzer.analyze();
            } catch (Exception e) {
                String attributeName = e.getMessage();
                System.out.println("new attribute: " + attributeName);
                customAttributes.add(attributeName);
            }
        }
    }

    private void extract(String path, String directory) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;
        ByteTokenizer byteTokenizer = new ByteTokenizer();

        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                ByteStructure byteStructure = byteAnalyzer.analyze();
                byteStructure.setFileName(s);

                byteTokenizer.generateNewFiles(byteStructure, directory);

                System.out.println("Success: " + s);
            } catch (Exception e) {
                System.out.println("Failed: " + s);
                e.printStackTrace();
            }
        }
    }

    private void findMethodWithSignature(String path, String methodName, String directory) {
        ByteReader byteReader = new ByteReader(path);
        List<String> filePaths = byteReader.readClassFilePaths();

        byte[] bytes;
        ByteTokenizer byteTokenizer = new ByteTokenizer();

        for(String s : filePaths) {
            bytes = byteReader.readClassFile(s);

            ByteAnalyzer byteAnalyzer = new ByteAnalyzer(bytes);
            try {
                ByteStructure byteStructure = byteAnalyzer.analyze();
                byteStructure.setFileName(s);

                byteTokenizer.findSpecificMethod(byteStructure, "", directory);

                System.out.println("Success: " + s);
            } catch (Exception e) {
                System.out.println("Failed: " + s);
                e.printStackTrace();
            }
        }
    }




    public static HashSet<String> getCustomAttributes() {
        return customAttributes;
    }

    public static void setCustomAttributes(HashSet<String> customAttributes) {
        ByteTok.customAttributes = customAttributes;
    }
}
